import type * as types from '@applitools/types';
import type { Context } from './context';
export declare type ElementState = {
    contentSize?: types.Size;
    scrollOffset?: types.Location;
    transforms?: any;
};
export declare class Element<TDriver, TContext, TElement, TSelector> {
    private _target;
    private _context;
    private _selector;
    private _index;
    private _state;
    private _originalOverflow;
    private _touchPadding;
    private _logger;
    protected readonly _spec: types.SpecDriver<TDriver, TContext, TElement, TSelector>;
    constructor(options: {
        spec: types.SpecDriver<TDriver, TContext, TElement, TSelector>;
        element?: TElement | Element<TDriver, TContext, TElement, TSelector>;
        context?: Context<TDriver, TContext, TElement, TSelector>;
        selector?: types.Selector<TSelector>;
        index?: number;
        logger?: any;
        root?: TElement;
    });
    get target(): TElement;
    get selector(): types.Selector<TSelector>;
    get context(): Context<TDriver, TContext, TElement, TSelector>;
    get driver(): import("./driver").Driver<TDriver, TContext, TElement, TSelector>;
    get isRef(): boolean;
    equals(element: Element<TDriver, TContext, TElement, TSelector> | TElement): Promise<boolean>;
    init(context: Context<TDriver, TContext, TElement, TSelector>): Promise<this>;
    getRegion(shouldIgnoreSafeRegion?: boolean): Promise<types.Region>;
    getClientRegion(): Promise<types.Region>;
    getContentSize(): Promise<types.Size>;
    isScrollable(): Promise<boolean>;
    isRoot(): Promise<boolean>;
    getTouchPadding(): Promise<number>;
    getText(): Promise<string>;
    getAttribute(name: string): Promise<string>;
    setAttribute(name: string, value: string): Promise<void>;
    scrollTo(offset: types.Location): Promise<types.Location>;
    translateTo(offset: types.Location): Promise<types.Location>;
    getScrollOffset(): Promise<types.Location>;
    getTranslateOffset(): Promise<types.Location>;
    getInnerOffset(): Promise<types.Location>;
    click(): Promise<void>;
    type(value: string): Promise<void>;
    preserveState(): Promise<ElementState>;
    restoreState(state?: ElementState): Promise<void>;
    hideScrollbars(): Promise<void>;
    restoreScrollbars(): Promise<void>;
    refresh(freshElement?: TElement): Promise<boolean>;
    withRefresh<TResult>(operation: (...args: any[]) => TResult): Promise<TResult>;
    toJSON(): TElement;
}
