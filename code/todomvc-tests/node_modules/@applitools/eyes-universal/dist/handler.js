"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeHandler = void 0;
const http_1 = require("http");
const ws_1 = require("ws");
const { name, version } = require('../package.json');
const TOKEN_HEADER = 'x-eyes-universal-token';
const TOKEN = `${name}@${version}`;
async function makeHandler({ port = 21077, singleton = true, lazy = false } = {}) {
    const http = new http_1.Server();
    http.on('request', (request, response) => {
        if (request.url === '/handshake') {
            if (request.headers[TOKEN_HEADER] === TOKEN) {
                response.writeHead(200, { [TOKEN_HEADER]: TOKEN });
            }
            else {
                response.writeHead(400);
            }
            response.end();
        }
    });
    http.listen(port, 'localhost');
    return new Promise((resolve, reject) => {
        http.on('listening', () => {
            const ws = new ws_1.Server({ server: http, path: '/eyes' });
            ws.on('close', () => http.close());
            resolve({ server: ws, port });
        });
        http.on('error', async (err) => {
            if (!lazy && err.code === 'EADDRINUSE') {
                if (singleton && (await isHandshakable(port))) {
                    return resolve({ port });
                }
                else {
                    return resolve(await makeHandler({ port: port + 1, singleton }));
                }
            }
            reject(err);
        });
    });
}
exports.makeHandler = makeHandler;
async function isHandshakable(port) {
    return new Promise(resolve => {
        const handshake = (0, http_1.request)(`http://localhost:${port}/handshake`, {
            headers: { [TOKEN_HEADER]: TOKEN },
        });
        handshake.on('response', ({ statusCode, headers }) => {
            resolve(statusCode === 200 && headers[TOKEN_HEADER] === TOKEN);
        });
        handshake.on('error', () => resolve(false));
        handshake.end();
    });
}
