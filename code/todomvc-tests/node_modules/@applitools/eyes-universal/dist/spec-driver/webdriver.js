"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = exports.performAction = exports.getElementText = exports.getElementAttribute = exports.getElementRegion = exports.getOrientation = exports.getBarsHeight = exports.type = exports.click = exports.takeScreenshot = exports.visit = exports.getUrl = exports.getTitle = exports.getDriverInfo = exports.getCapabilities = exports.getCookies = exports.setWindowSize = exports.getWindowSize = exports.findElements = exports.findElement = exports.childContext = exports.parentContext = exports.mainContext = exports.executeScript = exports.isEqualElements = exports.isStaleElementError = exports.transformSelector = exports.transformElement = exports.transformDriver = exports.isSelector = exports.isElement = exports.isDriver = void 0;
const utils = __importStar(require("@applitools/utils"));
const webdriver_1 = __importStar(require("webdriver"));
// #region HELPERS
const LEGACY_ELEMENT_ID = 'ELEMENT';
const ELEMENT_ID = 'element-6066-11e4-a52e-4f735466cecf';
const SHADOW_ROOT_ID = 'shadow-6066-11e4-a52e-4f735466cecf';
const W3C_CAPABILITIES = ['platformName', 'platformVersion'];
const W3C_SECONDARY_CAPABILITIES = ['pageLoadStrategy'];
const W3C_SAFARI_CAPABILITIES = ['browserVersion', 'setWindowRect'];
const APPIUM_CAPABILITIES = ['appiumVersion', 'deviceType', 'deviceOrientation', 'deviceName', 'automationName'];
const LEGACY_APPIUM_CAPABILITIES = ['appium-version', 'device-type', 'device-orientation'];
const CHROME_CAPABILITIES = ['chrome', 'goog:chromeOptions'];
const MOBILE_BROWSER_NAMES = ['ipad', 'iphone', 'android'];
function extractElementId(element) {
    var _a, _b;
    return (_b = (_a = element.elementId) !== null && _a !== void 0 ? _a : element[ELEMENT_ID]) !== null && _b !== void 0 ? _b : element[LEGACY_ELEMENT_ID];
}
function transformShadowRoot(shadowRoot) {
    return isElement(shadowRoot) ? shadowRoot : { [ELEMENT_ID]: shadowRoot[SHADOW_ROOT_ID] };
}
function extractEnvironment(capabilities) {
    var _a;
    const isAppium = APPIUM_CAPABILITIES.some(capability => capabilities.hasOwnProperty(capability));
    const isChrome = CHROME_CAPABILITIES.some(capability => capabilities.hasOwnProperty(capability));
    const isW3C = isAppium ||
        W3C_SECONDARY_CAPABILITIES.every(capability => capabilities.hasOwnProperty(capability)) ||
        W3C_CAPABILITIES.every(capability => capabilities.hasOwnProperty(capability)) ||
        W3C_SAFARI_CAPABILITIES.every(capability => capabilities.hasOwnProperty(capability));
    const isMobile = capabilities.browserName === '' ||
        isAppium ||
        LEGACY_APPIUM_CAPABILITIES.some(capability => capabilities.hasOwnProperty(capability)) ||
        MOBILE_BROWSER_NAMES.includes((_a = capabilities.browserName) === null || _a === void 0 ? void 0 : _a.toLowerCase());
    return {
        isW3C,
        isMobile,
        isChrome,
    };
}
// #endregion
// #region UTILITY
function isDriver(driver) {
    if (!driver)
        return false;
    return utils.types.has(driver, ['sessionId', 'serverUrl']) || utils.types.instanceOf(driver, 'Browser');
}
exports.isDriver = isDriver;
function isElement(element) {
    if (!element)
        return false;
    return Boolean(extractElementId(element));
}
exports.isElement = isElement;
function isSelector(selector) {
    if (!selector)
        return false;
    return utils.types.has(selector, ['using', 'value']);
}
exports.isSelector = isSelector;
function transformDriver(driver) {
    if (!utils.types.has(driver, ['sessionId', 'serverUrl']))
        return driver;
    const url = new URL(driver.serverUrl);
    const options = Object.assign({ sessionId: driver.sessionId, protocol: url.protocol ? url.protocol.replace(/:$/, '') : undefined, hostname: url.hostname, port: Number(url.port) || undefined, path: url.pathname, capabilities: driver.capabilities, logLevel: 'silent' }, extractEnvironment(driver.capabilities));
    if (!options.port) {
        if (options.protocol === 'http')
            options.port = 80;
        if (options.protocol === 'https')
            options.port = 443;
    }
    const additionalCommands = {
        _getWindowSize: {
            value: (0, webdriver_1.command)('GET', '/session/:sessionId/window/current/size', {
                command: '_getWindowSize',
                description: '',
                ref: '',
                parameters: [],
            }),
        },
        _setWindowSize: {
            value: (0, webdriver_1.command)('POST', '/session/:sessionId/window/current/size', {
                command: '_setWindowSize',
                parameters: [
                    { name: 'width', type: 'number', required: true, description: '' },
                    { name: 'height', type: 'number', required: true, description: '' },
                ],
                description: '',
                ref: '',
            }),
        },
        setWindowPosition: {
            value: (0, webdriver_1.command)('POST', '/session/:sessionId/window/current/position', {
                command: 'setWindowPosition',
                parameters: [
                    { name: 'x', type: 'number', required: true, description: '' },
                    { name: 'y', type: 'number', required: true, description: '' },
                ],
                description: '',
                ref: '',
            }),
        },
    };
    return webdriver_1.default.attachToSession(options, undefined, additionalCommands);
}
exports.transformDriver = transformDriver;
function transformElement(element) {
    if (!utils.types.has(element, 'elementId'))
        return element;
    return { [ELEMENT_ID]: element.elementId, [LEGACY_ELEMENT_ID]: element.elementId };
}
exports.transformElement = transformElement;
function transformSelector(selector) {
    if (utils.types.isString(selector)) {
        return { using: 'css selector', value: selector };
    }
    else if (utils.types.has(selector, 'selector')) {
        if (!utils.types.isString(selector.selector))
            return selector.selector;
        if (!utils.types.has(selector, 'type'))
            return { using: 'css selector', value: selector.selector };
        if (selector.type === 'css')
            return { using: 'css selector', value: selector.selector };
        else
            return { using: selector.type, value: selector.selector };
    }
    else {
        return selector;
    }
}
exports.transformSelector = transformSelector;
function isStaleElementError(error) {
    if (!error)
        return false;
    const errOrResult = error.originalError || error;
    return errOrResult instanceof Error && errOrResult.name === 'stale element reference';
}
exports.isStaleElementError = isStaleElementError;
// #endregion
// #region COMMANDS
async function isEqualElements(_driver, element1, element2) {
    if (!element1 || !element2)
        return false;
    const elementId1 = extractElementId(element1);
    const elementId2 = extractElementId(element2);
    return elementId1 === elementId2;
}
exports.isEqualElements = isEqualElements;
async function executeScript(driver, script, arg) {
    script = utils.types.isFunction(script) ? `return (${script}).apply(null, arguments)` : script;
    return driver.executeScript(script, [arg]);
}
exports.executeScript = executeScript;
async function mainContext(driver) {
    await driver.switchToFrame(null);
    return driver;
}
exports.mainContext = mainContext;
async function parentContext(driver) {
    await driver.switchToParentFrame();
    return driver;
}
exports.parentContext = parentContext;
async function childContext(driver, element) {
    await driver.switchToFrame(element);
    return driver;
}
exports.childContext = childContext;
async function findElement(driver, selector, parent) {
    const parentElement = parent ? transformShadowRoot(parent) : null;
    const element = parentElement
        ? await driver.findElementFromElement(extractElementId(parentElement), selector.using, selector.value)
        : await driver.findElement(selector.using, selector.value);
    return isElement(element) ? element : null;
}
exports.findElement = findElement;
async function findElements(driver, selector, parent) {
    const parentElement = parent ? transformShadowRoot(parent) : null;
    return parentElement
        ? await driver.findElementsFromElement(extractElementId(parentElement), selector.using, selector.value)
        : await driver.findElements(selector.using, selector.value);
}
exports.findElements = findElements;
async function getWindowSize(driver) {
    try {
        const rect = await driver.getWindowRect();
        return { width: rect.width, height: rect.height };
    }
    catch (_a) {
        return driver._getWindowSize();
    }
}
exports.getWindowSize = getWindowSize;
async function setWindowSize(driver, size) {
    try {
        await driver.setWindowRect(0, 0, size.width, size.height);
    }
    catch (_a) {
        await driver.setWindowPosition(0, 0);
        await driver._setWindowSize(size.width, size.height);
    }
}
exports.setWindowSize = setWindowSize;
async function getCookies(driver, context) {
    if (context)
        return driver.getAllCookies();
    const response = await driver.sendCommandAndGetResult('Network.getAllCookies', {});
    const cookies = response.cookies;
    return cookies.map((cookie) => {
        const copy = Object.assign(Object.assign({}, cookie), { expiry: cookie.expires });
        delete copy.expires;
        delete copy.size;
        delete copy.priority;
        delete copy.session;
        delete copy.sameParty;
        delete copy.sourceScheme;
        delete copy.sourcePort;
        return copy;
    });
}
exports.getCookies = getCookies;
async function getCapabilities(browser) {
    var _a, _b;
    return (_b = (_a = browser.getSession) === null || _a === void 0 ? void 0 : _a.call(browser)) !== null && _b !== void 0 ? _b : browser.capabilities;
}
exports.getCapabilities = getCapabilities;
async function getDriverInfo(driver) {
    return { sessionId: driver.sessionId };
}
exports.getDriverInfo = getDriverInfo;
async function getTitle(driver) {
    return driver.getTitle();
}
exports.getTitle = getTitle;
async function getUrl(driver) {
    return driver.getUrl();
}
exports.getUrl = getUrl;
async function visit(driver, url) {
    await driver.navigateTo(url);
}
exports.visit = visit;
async function takeScreenshot(driver) {
    return driver.takeScreenshot();
}
exports.takeScreenshot = takeScreenshot;
async function click(driver, element) {
    if (isSelector(element))
        element = await findElement(driver, element);
    await driver.elementClick(extractElementId(element));
}
exports.click = click;
async function type(driver, element, value) {
    await driver.elementSendKeys(extractElementId(element), value);
}
exports.type = type;
// #endregion
// #region NATIVE COMMANDS
async function getBarsHeight(browser) {
    const { statusBar, navigationBar } = await browser.getSystemBars();
    return {
        statusBarHeight: statusBar.visible ? statusBar.height : 0,
        navigationBarHeight: navigationBar.visible ? navigationBar.height : 0,
    };
}
exports.getBarsHeight = getBarsHeight;
async function getOrientation(browser) {
    const orientation = await browser.getOrientation();
    return orientation.toLowerCase();
}
exports.getOrientation = getOrientation;
async function getElementRegion(driver, element) {
    return driver.getElementRect(extractElementId(element));
}
exports.getElementRegion = getElementRegion;
async function getElementAttribute(driver, element, attr) {
    return driver.getElementAttribute(extractElementId(element), attr);
}
exports.getElementAttribute = getElementAttribute;
async function getElementText(driver, element) {
    return driver.getElementText(extractElementId(element));
}
exports.getElementText = getElementText;
async function performAction(driver, steps) {
    return driver.touchPerform(steps.map((_a) => {
        var { action } = _a, options = __rest(_a, ["action"]);
        return ({ action, options });
    }));
}
exports.performAction = performAction;
// #endregion
// #region TESTING
const browserOptionsNames = {
    chrome: 'goog:chromeOptions',
    firefox: 'moz:firefoxOptions',
};
async function build(env) {
    const parseEnv = require('@applitools/test-utils/src/parse-env');
    const { browser = '', capabilities, url, proxy, configurable = true, args = [], headless, logLevel = 'silent', } = parseEnv(env);
    const options = {
        capabilities: Object.assign({ browserName: browser }, capabilities),
        logLevel,
    };
    options.protocol = url.protocol ? url.protocol.replace(/:$/, '') : undefined;
    options.hostname = url.hostname;
    if (url.port)
        options.port = Number(url.port);
    else if (options.protocol === 'http')
        options.port = 80;
    else if (options.protocol === 'https')
        options.port = 443;
    options.path = url.pathname;
    if (configurable) {
        const browserOptionsName = browserOptionsNames[browser || options.capabilities.browserName];
        if (browserOptionsName) {
            const browserOptions = options.capabilities[browserOptionsName] || {};
            browserOptions.args = [...(browserOptions.args || []), ...args];
            if (headless)
                browserOptions.args.push('headless');
            options.capabilities[browserOptionsName] = browserOptions;
        }
    }
    if (proxy) {
        options.capabilities.proxy = {
            proxyType: 'manual',
            httpProxy: proxy.http || proxy.server,
            sslProxy: proxy.https || proxy.server,
            ftpProxy: proxy.ftp,
            noProxy: proxy.bypass.join(','),
        };
    }
    const driver = await webdriver_1.default.newSession(options);
    return [driver, () => driver.deleteSession()];
}
exports.build = build;
// #endregion
